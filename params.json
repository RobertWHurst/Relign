{
  "name": "Relign",
  "tagline": "Relign is a control flow library for promises heavily inspired by async",
  "body": "[![Travis](https://img.shields.io/travis/RobertWHurst/relign.svg)](https://travis-ci.org/RobertWHurst/relign)\r\n[![Coveralls](https://img.shields.io/coveralls/jekyll/jekyll.svg)](https://coveralls.io/github/RobertWHurst/relign)\r\n[![npm](https://img.shields.io/npm/v/relign.svg)](https://www.npmjs.com/package/relign)\r\n\r\n# Intro to relign\r\n\r\nrelign is a highly functional control flow library. It's heavily inspired by [async](https://github.com/caolan/async) but goes a bit further. relign treats all functions as values, and thus wherever you can pass a function to relign, it's also fine to pass a value. relign refers to both functions, functions that return promises, promises, and any other value as tasks.\r\n\r\nrelign's utilities are greatly inspired by [async](https://github.com/caolan/async). async is one of the most loved libraries on NPM, and there are many very good reasons for this. Async provides a lot of very powerful functions for taking unruly asynchronous code and making it both readable and reasonable. Async does this with the classic error first callback pattern popular in node. relign attempts to achieve a similar set of goals to async, but for promises. It provides a large collection of methods for processing collections of data, and controlling the execution of asynchronous code.\r\n\r\nIf you're starting a new project and want a good foundation for your control flow patterns, or you're planning on moving a project from node style callbacks, to the newer 'async await' style of control flow, relign may be just what you need.\r\n\r\n## Installing relign\r\n\r\nrelign can be installed from NPM.\r\n\r\n```shell\r\nnpm i relign --save\r\n```\r\n\r\nTo use relign you may simply require the function you need:\r\n\r\n```javascript\r\nconst parallel = require('relign/parallel');\r\n\r\nconst server   = require('./server');\r\nconst database = require('./database');\r\n\r\nparallel([\r\n  () => server.listen(),\r\n  () => database.connect()\r\n]).then(() => console.log('ready'));\r\n```\r\n\r\nor require the whole library:\r\n\r\n```javascript\r\nconst relign = require('relign');\r\n\r\nconst server   = require('./server');\r\nconst database = require('./database');\r\n\r\nrelign.parallel([\r\n  () => server.listen(),\r\n  () => database.connect()\r\n]).then(() => console.log('ready'));\r\n```\r\n\r\n## Docs\r\n\r\nThe following will cover the relign API and how to use it.\r\n\r\n### Control Flow\r\n\r\n#### Auto\r\n\r\n```javascript\r\nrelign.auto(autoTasks) -> promise(results)\r\n```\r\n\r\nAuto will execute tasks without dependencies first, as these dependencies resolve, any tasks dependent on them will be executed. The result is that a complex collection of dependencies can be resolved as fast as possible without complex control flow code.\r\n\r\nAuto executes an object containing arrays. These arrays each contain a task, proceeded by dependencies of the task, if any. Note that the dependencies are strings that match the key of another task within the given object. For reference see the example below. Tasks are any function or value that can be passed to [exec](#exec).\r\n\r\n```javascript\r\nrelign.auto({\r\n  mixingBowl: [() => getMixingBowl()],\r\n  cakeMix   : ['mixingBowl', r => addCakeMix(r.mixingBowl)],\r\n  milk      : ['mixingBowl', r => addMilk(r.mixingBowl)],\r\n  mix       : ['cakeMix', 'milk', r => mixContents(r.mixingBowl)],\r\n  hotOven   : [() => preheatOven()],\r\n  cake      : ['mix', 'hotOven', r => r.hotOven.bakeContents(r.mixingBowl)],\r\n}).then(results => eat(results.cake));\r\n```\r\n\r\n#### Parallel\r\n\r\n```javascript\r\nrelign.parallel(tasks) -> promise(results)\r\n```\r\n\r\nParallel is a great way to concurrently execute a collection of tasks then wait for all of them to complete.\r\n\r\nParallel accepts an array or object containing tasks. A task is a function or value accepted by [exec](#exec). Parallel will execute all of the tasks and return a promise. This promise will resolve once all of the tasks have resolved. The resolved results will be an array or object matching the keys/indexes of each task. Each task result will be present in the same key/index as the task that produced it.\r\n\r\nBelow is two examples of how you might start a server and connect to a database concurrently. The first example uses a task object, and the second uses a task array. These examples are functionally equivalent.\r\n\r\n```javascript\r\nrelign.parallel({\r\n  server  : () => server.listen(),\r\n  database: () => database.connect()\r\n}).then(results => console.log(`Server listening on port ${results.server.port}`));\r\n```\r\n\r\n```javascript\r\nrelign.parallel([\r\n  server.listen(),\r\n  database.connect()\r\n]).then(results => console.log(`Server listening on port ${results[0].port}`));\r\n```\r\n\r\n#### Parallel Limit\r\n\r\n```javascript\r\nrelign.parallelLimit(tasks, limit) -> promise(results)\r\n```\r\n\r\nSimilar to [parallel](#parallel), parallel limit is a great way to concurrently execute a collection of tasks, but with an added ability to limit the maximum task concurrency.\r\n\r\nParallel limit accepts an array or object containing tasks, and a limit. A task is a function or value that can be accepted by [exec](#exec). The limit is the maximum number of tasks that can be executed simultaneously. Like parallel, parallel limit returns a promise that resolves once all of the tasks have resolved. The resolved results will be an array or object matching the keys/indexes of each task. Each task result will be present in the same key/index as the task that produced it.\r\n\r\nBelow is two examples of how parallel limit might be used to load a collection of files into memory then parse their contents. Note that only two files can be loaded concurrency as instructed by the second argument passed to parallel limit.\r\n\r\n```javascript\r\nrelign.parallelLimit({\r\n  fileOne  : () => loadFileOne(),\r\n  fileTwo  : () => loadFileTwo(),\r\n  fileThree: () => loadFileThree(),\r\n  fileFour : () => loadFileFour()\r\n}, 2).then(files => parse(files));\r\n```\r\n\r\n```javascript\r\nrelign.parallelLimit([\r\n  () => loadFileOne(),\r\n  () => loadFileTwo(),\r\n  () => loadFileThree(),\r\n  () => loadFileFour()\r\n], 2).then(files => parse(files));\r\n```\r\n\r\n#### Series\r\n\r\n```javascript\r\nrelign.series(tasks) -> promise(results)\r\n```\r\n\r\nSeries provides a way for executing tasks in order. If all of your tasks happen to be promise returning functions then you could do this with an async function, but relign tasks can be any value [exec](#exec) accepts. This makes relign series much more flexible.\r\n\r\nSeries accepts an array or object of tasks. It will execute each of the tasks in the key/index order they are defined in. It returns a promise that will resolve once all of the tasks have resolved.\r\n\r\n#### Parallel Map\r\n\r\n```javascript\r\nrelign.parallelMap(items, worker(item) -> promise(result)) -> promise(results)\r\nrelign.parallelMap(items, worker(item) -> result) -> promise(results)\r\n```\r\n\r\nIf you've needed to process data concurrently you know how hard it can be. Parallel map makes the job of concurrently processing data much easier.\r\n\r\nParallel map accepts an array or object and a worker function. The worker function is executed once for each value within the array/object. The item is passed as the first argument of the worker function. The worker can return a promise, or a value. Parallel map returns a promise which once the worker has been executed upon all of the items, and any promises it returned have resolved the returned promise will resolve.\r\n\r\nBelow is an example of how you might take an array of resource urls, download each resource, then store the collection of resources.\r\n\r\n```javascript\r\nrelign.parallelMap(resourceUrls, url => download(url))\r\n  .then(resources => store(resources));\r\n```\r\n\r\n\r\n#### Parallel Map Limit\r\n\r\n```javascript\r\nrelign.parallelMapLimit(items, worker(item) -> promise(result), limit) -> promise(results)\r\n```\r\n\r\nParallel map limit is just like parallel map, but it limits the maximum concurrency. When working with larger data sets you want to limit your maximum concurrently. parallel map is great for working with smaller data sets, but for larger ones the sensible thing to do is limit the maximum concurrency.\r\n\r\nParallel map limit accepts an array or object and a worker function. The worker function is executed once for each value within the array/object. The item is passed as the first argument of the worker function. The worker can return a promise, or a value. Parallel map limit returns a promise which once the worker has been executed upon all of the items, and any promises it returned have resolved the returned promise will resolve.\r\n\r\nBelow is an example of how you might take an array of resource urls, download each resource, then store the collection of resources. In this example the number of resources that can be downloaded at once is six.\r\n\r\n```javascript\r\nrelign.parallelMap(resourceUrls, url => download(url), 6)\r\n  .then(resources => store(resources));\r\n```\r\n\r\n#### Series Map\r\n\r\n```javascript\r\nrelign.seriesMap(items, worker(item) -> promise(result)) -> promise(results)\r\n```\r\n\r\nIn the event you have to process a data set serially with asynchronous logic then you probably need series map.\r\n\r\nSeries map accepts an array or object and a worker function. The worker function is executed once for each value within the array/object. The item is passed as the first argument of the worker function. The worker can return a promise, or a value. Series map returns a promise which once the worker has been executed upon all of the items, and any promises it returned have resolved the returned promise will resolve.\r\n\r\n#### Parallel Filter\r\n\r\n```javascript\r\nrelign.parallelFilter(items, tester) -> promise(filteredItems)\r\n```\r\n\r\n#### Parallel Filter Limit\r\n\r\n```javascript\r\nrelign.parallelFilterLimit(items, tester) -> promise(filteredItems)\r\n```\r\n\r\n#### Series Filter\r\n\r\n```javascript\r\nrelign.seriesFilter(items, tester) -> promise(filteredItems)\r\n```\r\n\r\n#### Parallel Find\r\n\r\n```javascript\r\nrelign.parallelFind(items, tester) -> promise(item)\r\n```\r\n\r\n#### Parallel Find Limit\r\n\r\n```javascript\r\nrelign.parallelFindLimit(items, tester, limit) -> promise(item)\r\n```\r\n\r\n#### Series Find\r\n\r\n```javascript\r\nrelign.seriesFind(items, tester) -> promise(item)\r\n```\r\n\r\n#### Parallel Concat\r\n\r\n```javascript\r\nrelign.parallelConcat(items, worker(item) -> promise(result)) -> promise(results)\r\n```\r\n\r\n#### Series Concat\r\n\r\n```javascript\r\nrelign.seriesConcat(items, worker(item) -> promise(result)) -> promise(results)\r\n```\r\n\r\n### Utilities\r\n\r\n#### Exec\r\n\r\n```javascript\r\nrelign.exec(fn() => promise(result)) -> promise(result)\r\nrelign.exec(fn() => result) -> promise(result)\r\nrelign.exec(value) -> promise(value)\r\n```\r\n\r\nExec is used to convert any value to a promise. It's used extensively by relign internally for normalizing tasks. Exec makes relign a breeze to use because with it you can treat all functions as values. If given a function exec will execute it. Should the function return a promise then exec will return it. If the function instead returns a value, then relign will return a promise that resolves the value immediately. If exec is passed a promise, then it will return the promise. If exec is passed any other type of value other than a function, it will return a promise that resolves the value immediately.\r\n\r\n#### Next Tick\r\n\r\n```javascript\r\nrelign.nextTick(fn() -> promise(result)) -> promise(result)\r\nrelign.nextTick(fn() -> result) -> promise(result)\r\nrelign.nextTick(value) -> promise(value)\r\nrelign.nextTick() -> promise()\r\n```\r\n\r\nNext tick is a wrapper for node's built in next tick. It executes a given\r\nfunction in the following tick, and resolves in the value returned or resolved\r\nby the function. If a value is given instead of a function, then the value will\r\nbe resolved the following tick.\r\n\r\n#### Set Interval\r\n\r\n```javascript\r\nrelign.setInterval(fn() -> promise(), duration) -> intervalPromise()\r\nrelign.setInterval(fn(), duration) -> intervalPromise()\r\n```\r\n\r\n#### Set Timeout\r\n\r\n```javascript\r\nrelign.setTimeout(fn() -> promise(result), duration) -> timeoutPromise(result)\r\nrelign.setTimeout(fn() -> result, duration) -> timeoutPromise(result)\r\nrelign.setTimeout(value, duration) -> timeoutPromise(value)\r\nrelign.setTimeout(duration) -> timeoutPromise()\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}