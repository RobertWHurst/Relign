<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Relign by RobertWHurst</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Relign</h1>
      <h2 class="project-tagline">Relign is a control flow library for promises heavily inspired by async</h2>
      <a href="https://github.com/RobertWHurst/relign" class="btn">View on GitHub</a>
      <a href="https://github.com/RobertWHurst/relign/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/RobertWHurst/relign/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><a href="https://travis-ci.org/RobertWHurst/relign"><img src="https://img.shields.io/travis/RobertWHurst/relign.svg" alt="Travis"></a>
<a href="https://coveralls.io/github/RobertWHurst/relign"><img src="https://img.shields.io/coveralls/jekyll/jekyll.svg" alt="Coveralls"></a>
<a href="https://www.npmjs.com/package/relign"><img src="https://img.shields.io/npm/v/relign.svg" alt="npm"></a></p>

<h1>
<a id="intro-to-relign" class="anchor" href="#intro-to-relign" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Intro to relign</h1>

<p>relign is a highly functional control flow library. It's heavily inspired by <a href="https://github.com/caolan/async">async</a> but goes a bit further. relign treats all functions as values, and thus wherever you can pass a function to relign, it's also fine to pass a value. relign refers to both functions, functions that return promises, promises, and any other value as tasks.</p>

<p>relign's utilities are greatly inspired by <a href="https://github.com/caolan/async">async</a>. async is one of the most loved libraries on NPM, and there are many very good reasons for this. Async provides a lot of very powerful functions for taking unruly asynchronous code and making it both readable and reasonable. Async does this with the classic error first callback pattern popular in node. relign attempts to achieve a similar set of goals to async, but for promises. It provides a large collection of methods for processing collections of data, and controlling the execution of asynchronous code.</p>

<p>If you're starting a new project and want a good foundation for your control flow patterns, or you're planning on moving a project from node style callbacks, to the newer 'async await' style of control flow, relign may be just what you need.</p>

<h2>
<a id="installing-relign" class="anchor" href="#installing-relign" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing relign</h2>

<p>relign can be installed from NPM.</p>

<div class="highlight highlight-source-shell"><pre>npm i relign --save</pre></div>

<p>To use relign you may simply require the function you need:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">parallel</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>relign/parallel<span class="pl-pds">'</span></span>);

<span class="pl-k">const</span> <span class="pl-c1">server</span>   <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./server<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">database</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./database<span class="pl-pds">'</span></span>);

<span class="pl-en">parallel</span>([
  () <span class="pl-k">=&gt;</span> <span class="pl-smi">server</span>.<span class="pl-en">listen</span>(),
  () <span class="pl-k">=&gt;</span> <span class="pl-smi">database</span>.<span class="pl-en">connect</span>()
]).<span class="pl-en">then</span>(() <span class="pl-k">=&gt;</span> <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>ready<span class="pl-pds">'</span></span>));</pre></div>

<p>or require the whole library:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">relign</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>relign<span class="pl-pds">'</span></span>);

<span class="pl-k">const</span> <span class="pl-c1">server</span>   <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./server<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">database</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./database<span class="pl-pds">'</span></span>);

<span class="pl-smi">relign</span>.<span class="pl-en">parallel</span>([
  () <span class="pl-k">=&gt;</span> <span class="pl-smi">server</span>.<span class="pl-en">listen</span>(),
  () <span class="pl-k">=&gt;</span> <span class="pl-smi">database</span>.<span class="pl-en">connect</span>()
]).<span class="pl-en">then</span>(() <span class="pl-k">=&gt;</span> <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>ready<span class="pl-pds">'</span></span>));</pre></div>

<h2>
<a id="docs" class="anchor" href="#docs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Docs</h2>

<p>The following will cover the relign API and how to use it.</p>

<h3>
<a id="control-flow" class="anchor" href="#control-flow" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Control Flow</h3>

<h4>
<a id="auto" class="anchor" href="#auto" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Auto</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">auto</span>(autoTasks) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<p>Auto will execute tasks without dependencies first, as these dependencies resolve, any tasks dependent on them will be executed. The result is that a complex collection of dependencies can be resolved as fast as possible without complex control flow code.</p>

<p>Auto executes an object containing arrays. These arrays each contain a task, proceeded by dependencies of the task, if any. Note that the dependencies are strings that match the key of another task within the given object. For reference see the example below. Tasks are any function or value that can be passed to <a href="#exec">exec</a>.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">auto</span>({
  mixingBowl<span class="pl-k">:</span> [() <span class="pl-k">=&gt;</span> <span class="pl-en">getMixingBowl</span>()],
  cakeMix   <span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>mixingBowl<span class="pl-pds">'</span></span>, <span class="pl-smi">r</span> <span class="pl-k">=&gt;</span> <span class="pl-en">addCakeMix</span>(<span class="pl-smi">r</span>.<span class="pl-smi">mixingBowl</span>)],
  milk      <span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>mixingBowl<span class="pl-pds">'</span></span>, <span class="pl-smi">r</span> <span class="pl-k">=&gt;</span> <span class="pl-en">addMilk</span>(<span class="pl-smi">r</span>.<span class="pl-smi">mixingBowl</span>)],
  mix       <span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>cakeMix<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>milk<span class="pl-pds">'</span></span>, <span class="pl-smi">r</span> <span class="pl-k">=&gt;</span> <span class="pl-en">mixContents</span>(<span class="pl-smi">r</span>.<span class="pl-smi">mixingBowl</span>)],
  hotOven   <span class="pl-k">:</span> [() <span class="pl-k">=&gt;</span> <span class="pl-en">preheatOven</span>()],
  cake      <span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>mix<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>hotOven<span class="pl-pds">'</span></span>, <span class="pl-smi">r</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">r</span>.<span class="pl-smi">hotOven</span>.<span class="pl-en">bakeContents</span>(<span class="pl-smi">r</span>.<span class="pl-smi">mixingBowl</span>)],
}).<span class="pl-en">then</span>(<span class="pl-smi">results</span> <span class="pl-k">=&gt;</span> <span class="pl-en">eat</span>(<span class="pl-smi">results</span>.<span class="pl-smi">cake</span>));</pre></div>

<h4>
<a id="parallel" class="anchor" href="#parallel" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallel</span>(tasks) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<p>Parallel is a great way to concurrently execute a collection of tasks then wait for all of them to complete.</p>

<p>Parallel accepts an array or object containing tasks. A task is a function or value accepted by <a href="#exec">exec</a>. Parallel will execute all of the tasks and return a promise. This promise will resolve once all of the tasks have resolved. The resolved results will be an array or object matching the keys/indexes of each task. Each task result will be present in the same key/index as the task that produced it.</p>

<p>Below is two examples of how you might start a server and connect to a database concurrently. The first example uses a task object, and the second uses a task array. These examples are functionally equivalent.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallel</span>({
  <span class="pl-en">server</span>  <span class="pl-k">:</span> () <span class="pl-k">=&gt;</span> <span class="pl-smi">server</span>.<span class="pl-en">listen</span>(),
  <span class="pl-en">database</span><span class="pl-k">:</span> () <span class="pl-k">=&gt;</span> <span class="pl-smi">database</span>.<span class="pl-en">connect</span>()
}).<span class="pl-en">then</span>(<span class="pl-smi">results</span> <span class="pl-k">=&gt;</span> <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">`</span>Server listening on port <span class="pl-s1"><span class="pl-pse">${</span><span class="pl-smi">results</span>.<span class="pl-smi">server</span>.<span class="pl-c1">port</span><span class="pl-pse">}</span></span><span class="pl-pds">`</span></span>));</pre></div>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallel</span>([
  <span class="pl-smi">server</span>.<span class="pl-en">listen</span>(),
  <span class="pl-smi">database</span>.<span class="pl-en">connect</span>()
]).<span class="pl-en">then</span>(<span class="pl-smi">results</span> <span class="pl-k">=&gt;</span> <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">`</span>Server listening on port <span class="pl-s1"><span class="pl-pse">${</span>results[<span class="pl-c1">0</span>].<span class="pl-c1">port</span><span class="pl-pse">}</span></span><span class="pl-pds">`</span></span>));</pre></div>

<h4>
<a id="parallel-limit" class="anchor" href="#parallel-limit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Limit</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelLimit</span>(tasks, limit) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<p>Similar to <a href="#parallel">parallel</a>, parallel limit is a great way to concurrently execute a collection of tasks, but with an added ability to limit the maximum task concurrency.</p>

<p>Parallel limit accepts an array or object containing tasks, and a limit. A task is a function or value that can be accepted by <a href="#exec">exec</a>. The limit is the maximum number of tasks that can be executed simultaneously. Like parallel, parallel limit returns a promise that resolves once all of the tasks have resolved. The resolved results will be an array or object matching the keys/indexes of each task. Each task result will be present in the same key/index as the task that produced it.</p>

<p>Below is two examples of how parallel limit might be used to load a collection of files into memory then parse their contents. Note that only two files can be loaded concurrency as instructed by the second argument passed to parallel limit.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelLimit</span>({
  <span class="pl-en">fileOne</span>  <span class="pl-k">:</span> () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileOne</span>(),
  <span class="pl-en">fileTwo</span>  <span class="pl-k">:</span> () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileTwo</span>(),
  <span class="pl-en">fileThree</span><span class="pl-k">:</span> () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileThree</span>(),
  <span class="pl-en">fileFour</span> <span class="pl-k">:</span> () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileFour</span>()
}, <span class="pl-c1">2</span>).<span class="pl-en">then</span>(<span class="pl-smi">files</span> <span class="pl-k">=&gt;</span> <span class="pl-en">parse</span>(files));</pre></div>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelLimit</span>([
  () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileOne</span>(),
  () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileTwo</span>(),
  () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileThree</span>(),
  () <span class="pl-k">=&gt;</span> <span class="pl-en">loadFileFour</span>()
], <span class="pl-c1">2</span>).<span class="pl-en">then</span>(<span class="pl-smi">files</span> <span class="pl-k">=&gt;</span> <span class="pl-en">parse</span>(files));</pre></div>

<h4>
<a id="series" class="anchor" href="#series" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Series</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">series</span>(tasks) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<p>Series provides a way for executing tasks in order. If all of your tasks happen to be promise returning functions then you could do this with an async function, but relign tasks can be any value <a href="#exec">exec</a> accepts. This makes relign series much more flexible.</p>

<p>Series accepts an array or object of tasks. It will execute each of the tasks in the key/index order they are defined in. It returns a promise that will resolve once all of the tasks have resolved.</p>

<h4>
<a id="parallel-map" class="anchor" href="#parallel-map" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Map</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelMap</span>(items, <span class="pl-en">worker</span>(item) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)
<span class="pl-smi">relign</span>.<span class="pl-en">parallelMap</span>(items, <span class="pl-en">worker</span>(item) <span class="pl-k">-</span><span class="pl-k">&gt;</span> result) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<p>If you've needed to process data concurrently you know how hard it can be. Parallel map makes the job of concurrently processing data much easier.</p>

<p>Parallel map accepts an array or object and a worker function. The worker function is executed once for each value within the array/object. The item is passed as the first argument of the worker function. The worker can return a promise, or a value. Parallel map returns a promise which once the worker has been executed upon all of the items, and any promises it returned have resolved the returned promise will resolve.</p>

<p>Below is an example of how you might take an array of resource urls, download each resource, then store the collection of resources.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelMap</span>(resourceUrls, <span class="pl-smi">url</span> <span class="pl-k">=&gt;</span> <span class="pl-en">download</span>(url))
  .<span class="pl-en">then</span>(<span class="pl-smi">resources</span> <span class="pl-k">=&gt;</span> <span class="pl-en">store</span>(resources));</pre></div>

<h4>
<a id="parallel-map-limit" class="anchor" href="#parallel-map-limit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Map Limit</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelMapLimit</span>(items, <span class="pl-en">worker</span>(item) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result), limit) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<p>Parallel map limit is just like parallel map, but it limits the maximum concurrency. When working with larger data sets you want to limit your maximum concurrently. parallel map is great for working with smaller data sets, but for larger ones the sensible thing to do is limit the maximum concurrency.</p>

<p>Parallel map limit accepts an array or object and a worker function. The worker function is executed once for each value within the array/object. The item is passed as the first argument of the worker function. The worker can return a promise, or a value. Parallel map limit returns a promise which once the worker has been executed upon all of the items, and any promises it returned have resolved the returned promise will resolve.</p>

<p>Below is an example of how you might take an array of resource urls, download each resource, then store the collection of resources. In this example the number of resources that can be downloaded at once is six.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelMap</span>(resourceUrls, <span class="pl-smi">url</span> <span class="pl-k">=&gt;</span> <span class="pl-en">download</span>(url), <span class="pl-c1">6</span>)
  .<span class="pl-en">then</span>(<span class="pl-smi">resources</span> <span class="pl-k">=&gt;</span> <span class="pl-en">store</span>(resources));</pre></div>

<h4>
<a id="series-map" class="anchor" href="#series-map" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Series Map</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">seriesMap</span>(items, <span class="pl-en">worker</span>(item) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<p>In the event you have to process a data set serially with asynchronous logic then you probably need series map.</p>

<p>Series map accepts an array or object and a worker function. The worker function is executed once for each value within the array/object. The item is passed as the first argument of the worker function. The worker can return a promise, or a value. Series map returns a promise which once the worker has been executed upon all of the items, and any promises it returned have resolved the returned promise will resolve.</p>

<h4>
<a id="parallel-filter" class="anchor" href="#parallel-filter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Filter</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelFilter</span>(items, tester) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(filteredItems)</pre></div>

<h4>
<a id="parallel-filter-limit" class="anchor" href="#parallel-filter-limit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Filter Limit</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelFilterLimit</span>(items, tester) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(filteredItems)</pre></div>

<h4>
<a id="series-filter" class="anchor" href="#series-filter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Series Filter</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">seriesFilter</span>(items, tester) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(filteredItems)</pre></div>

<h4>
<a id="parallel-find" class="anchor" href="#parallel-find" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Find</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelFind</span>(items, tester) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(item)</pre></div>

<h4>
<a id="parallel-find-limit" class="anchor" href="#parallel-find-limit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Find Limit</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelFindLimit</span>(items, tester, limit) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(item)</pre></div>

<h4>
<a id="series-find" class="anchor" href="#series-find" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Series Find</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">seriesFind</span>(items, tester) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(item)</pre></div>

<h4>
<a id="parallel-concat" class="anchor" href="#parallel-concat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Concat</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">parallelConcat</span>(items, <span class="pl-en">worker</span>(item) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<h4>
<a id="series-concat" class="anchor" href="#series-concat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Series Concat</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">seriesConcat</span>(items, <span class="pl-en">worker</span>(item) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(results)</pre></div>

<h3>
<a id="utilities" class="anchor" href="#utilities" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Utilities</h3>

<h4>
<a id="exec" class="anchor" href="#exec" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Exec</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-c1">exec</span>(<span class="pl-en">fn</span>() <span class="pl-k">=&gt;</span> <span class="pl-en">promise</span>(result)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)
<span class="pl-smi">relign</span>.<span class="pl-c1">exec</span>(<span class="pl-en">fn</span>() <span class="pl-k">=&gt;</span> result) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)
<span class="pl-smi">relign</span>.<span class="pl-c1">exec</span>(value) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(value)</pre></div>

<p>Exec is used to convert any value to a promise. It's used extensively by relign internally for normalizing tasks. Exec makes relign a breeze to use because with it you can treat all functions as values. If given a function exec will execute it. Should the function return a promise then exec will return it. If the function instead returns a value, then relign will return a promise that resolves the value immediately. If exec is passed a promise, then it will return the promise. If exec is passed any other type of value other than a function, it will return a promise that resolves the value immediately.</p>

<h4>
<a id="next-tick" class="anchor" href="#next-tick" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Next Tick</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">nextTick</span>(<span class="pl-en">fn</span>() <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)
<span class="pl-smi">relign</span>.<span class="pl-en">nextTick</span>(<span class="pl-en">fn</span>() <span class="pl-k">-</span><span class="pl-k">&gt;</span> result) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result)
<span class="pl-smi">relign</span>.<span class="pl-en">nextTick</span>(value) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(value)
<span class="pl-smi">relign</span>.<span class="pl-en">nextTick</span>() <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>()</pre></div>

<p>Next tick is a wrapper for node's built in next tick. It executes a given
function in the following tick, and resolves in the value returned or resolved
by the function. If a value is given instead of a function, then the value will
be resolved the following tick.</p>

<h4>
<a id="set-interval" class="anchor" href="#set-interval" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Set Interval</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">setInterval</span>(<span class="pl-en">fn</span>() <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(), duration) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">intervalPromise</span>()
<span class="pl-smi">relign</span>.<span class="pl-en">setInterval</span>(<span class="pl-en">fn</span>(), duration) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">intervalPromise</span>()</pre></div>

<h4>
<a id="set-timeout" class="anchor" href="#set-timeout" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Set Timeout</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">relign</span>.<span class="pl-en">setTimeout</span>(<span class="pl-en">fn</span>() <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">promise</span>(result), duration) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">timeoutPromise</span>(result)
<span class="pl-smi">relign</span>.<span class="pl-en">setTimeout</span>(<span class="pl-en">fn</span>() <span class="pl-k">-</span><span class="pl-k">&gt;</span> result, duration) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">timeoutPromise</span>(result)
<span class="pl-smi">relign</span>.<span class="pl-en">setTimeout</span>(value, duration) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">timeoutPromise</span>(value)
<span class="pl-smi">relign</span>.<span class="pl-en">setTimeout</span>(duration) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">timeoutPromise</span>()</pre></div>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/RobertWHurst/relign">Relign</a> is maintained by <a href="https://github.com/RobertWHurst">RobertWHurst</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
